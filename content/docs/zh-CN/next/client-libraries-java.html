<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Pulsar Java客户端 · Apache Pulsar</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Pulsar Java 客户端可以用于创建Java生产者（Producer）和消费者（Consumer），消息[读取器](#reader-interface)以及执行[管理的任务](/docs/zh-CN/next/admin-api-overview) Java 客户端的当前版本为 **2.4.1**。"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="Pulsar Java客户端 · Apache Pulsar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pulsar.incubator.apache.org/"/><meta property="og:description" content="Pulsar Java 客户端可以用于创建Java生产者（Producer）和消费者（Consumer），消息[读取器](#reader-interface)以及执行[管理的任务](/docs/zh-CN/next/admin-api-overview) Java 客户端的当前版本为 **2.4.1**。"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://pulsar.incubator.apache.org/img/pulsar.svg"/><link rel="shortcut icon" href="/img/pulsar.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://pulsar.incubator.apache.org/blog/atom.xml" title="Apache Pulsar Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://pulsar.incubator.apache.org/blog/feed.xml" title="Apache Pulsar Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-102219959-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/custom.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/pulsar.svg" alt="Apache Pulsar"/></a><a href="/zh-CN/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/standalone" target="_self">文档</a></li><li class=""><a href="/zh-CN/download" target="_self">下载</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/client-libraries" target="_self">客户端</a></li><li class=""><a href="#restapis" target="_self">REST API</a></li><li class=""><a href="/blog/" target="_self">博客</a></li><li class=""><a href="#community" target="_self">社区</a></li><li class=""><a href="#apache" target="_self">Apache</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/next/client-libraries-java">English</a></li><li><a href="/docs/ja/next/client-libraries-java">日本語</a></li><li><a href="/docs/fr/next/client-libraries-java">Français</a></li><li><a href="https://crowdin.com/project/apache-pulsar" target="_blank" rel="noreferrer noopener">参与翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>客户端库</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Get started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/pulsar-2.0">Pulsar-2.0</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone">在本地运行Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone-docker">在Docker中运行Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries">Use Pulsar with client libraries</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">概念和架构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-messaging">消息传送</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-architecture-overview">Architecture</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-clients">客户端</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-replication">基于地理位置的备份</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-multi-tenancy">多租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-authentication">认证和授权</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-topic-compaction">消息压缩</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-tiered-storage">Tiered Storage</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-schema-registry">concepts-schema-registry</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Schema</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-get-started">Get started</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-understand">Understand schema</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-evolution-compatibility">Schema evolution and compatibility</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-manage">Manage schema</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Functions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-worker">Setup: Pulsar Functions Worker</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-runtime">Setup: Configure Functions runtime</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-develop">How-to: Develop</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-debug">How-to: Debug</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-deploy">How-to: Deploy</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-cli">Reference: CLI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar IO</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-quickstart">Get started</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-use">Use</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-debug">Debug</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-connectors">内置连接器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cdc">CDC 连接器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-develop">Develop</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cli">CLI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar SQL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-getting-started">Query data</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-deployment-configurations">部署和配置</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">部署</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-aws">Amazon Web Services</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-kubernetes">Kubernetes</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal">裸机</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal-multi-cluster">裸机多集群部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-dcos">DC/OS</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-monitoring">Monitoring</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">系统管理</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-zk-bk">ZooKeeper and BookKeeper</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-geo">跨地域复制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-dashboard">仪表盘</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-stats">Pulsar statistics</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-load-balance">Load balance</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-proxy">Pulsar proxy</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-upgrade">Upgrade</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">安全</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-transport">使用TLS进行传输加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-authentication">使用TLS进行认证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-jwt">Authentication using JWT</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-athenz">Authentication using Athenz</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-kerberos">Authentication using Kerberos</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-authorization">Authorization and ACLs</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-encryption">End-to-End Encryption</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-extending">Extending</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">客户端库</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-CN/next/client-libraries-java">Java</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-go">Go</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-python">Python</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-cpp">C++</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-node">Node.js
</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-websocket">WebSocket</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Admin API</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-clusters">集群</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-tenants">租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-brokers">Brokers</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-namespaces">命名空间</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-permissions">Permissions</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-persistent-topics">持久topic</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-non-persistent-topics">非持久topic</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-partitioned-topics">Partitioned topics</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-non-partitioned-topics">非分区主题</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-schemas">Schema</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-functions">Functions</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">适配器</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-kafka">Kafka 客户端封装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-spark">Apache Spark</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-storm">Apache Storm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考手册</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-tiered-storage">Tiered Storage</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-compaction">Topic compaction</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-deduplication">Message deduplication</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-non-persistent">非持久化消息</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-partitioned">分区主题</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-retention-expiry">消息保留和到期</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-encryption">Encryption</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-message-queue">消息队列</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-bookkeepermetadata">BookKeeper Ledger Metadata</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">开发</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-tools">Simulation tools</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-binary-protocol">Binary protocol</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-load-manager">Modular load manager</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-cpp">编译Pulsar C++ 客户端</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-terminology">术语</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-cli-tools">Pulsar CLI tools</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/pulsar-admin">Pulsar Admin CLI</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-connector-admin">Connector Admin CLI</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-configuration">Pulsar configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-metrics">Pulsar Metrics</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/apache-pulsar/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">Pulsar Java客户端</h1></header><article><div><span><p>Pulsar Java 客户端可以用于创建Java生产者（Producer）和消费者（Consumer），消息<a href="#reader-interface">读取器</a>以及执行<a href="/docs/zh-CN/next/admin-api-overview">管理的任务</a> Java 客户端的当前版本为 <strong>2.4.1</strong>。</p>
<p>Pulsar客户端的Javadoc分成了两个包:</p>
<table>
<thead>
<tr><th style="text-align:left">包</th><th style="text-align:left">说明：</th><th style="text-align:left">Maven Artifact</th></tr>
</thead>
<tbody>
<tr><td style="text-align:left"><a href="/api/client"><code>org.apache.pulsar.client.api</code></a></td><td style="text-align:left">生产者和消费者API</td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.4.1%7Cjar">org.apache.pulsar:pulsar-client:2.4.1</a></td></tr>
<tr><td style="text-align:left"><a href="/api/admin"><code>org.apache.pulsar.client.admin</code></a></td><td style="text-align:left">Java <a href="/docs/zh-CN/next/admin-api-overview">管理API</a></td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-admin%7C2.4.1%7Cjar">org.apache.pulsar:pulsar-client-admin:2.4.1</a></td></tr>
</tbody>
</table>
<p>本文档仅关注Pulsar主题消息的生产和消费的客户端API. 关于使用 Java 管理客户端的指南, 请参见 <a href="/docs/zh-CN/next/admin-api-overview">Pulsar管理接口</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="安装"></a><a href="#安装" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装</h2>
<p>最新版本的Pulsar Java 客户端库可通过 <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.4.1%7Cjar">Maven中央仓库</a> 使用。 要使用最新版本, 请将 <code>pulsar-client</code> 库添加到构建配置中。</p>
<h3><a class="anchor" aria-hidden="true" id="maven"></a><a href="#maven" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maven</h3>
<p>如果你使用maven,添加以下内容到你的 <code>pom.xml</code> 中:</p>
<pre><code class="hljs css language-xml"><span class="hljs-comment">&lt;!-- 在你的 &lt;properties&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">pulsar.version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">pulsar.version</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 在你的 &lt;dependencies&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.pulsar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pulsar-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${pulsar.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="gradle"></a><a href="#gradle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gradle</h3>
<p>如果你使用Gradle,添加以下内容到你的 <code>build.gradle</code> 中:</p>
<pre><code class="hljs css language-groovy"><span class="hljs-keyword">def</span> pulsarVersion = <span class="hljs-string">'2.4.1'</span>

dependencies {
    compile <span class="hljs-string">group:</span> <span class="hljs-string">'org.apache.pulsar'</span>, <span class="hljs-string">name:</span> <span class="hljs-string">'pulsar-client'</span>, <span class="hljs-string">version:</span> pulsarVersion
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="连接url"></a><a href="#连接url" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>连接URL</h2>
<p>要使用客户端连接到Pulsar，你需要指定<a href="/docs/zh-CN/next/develop-binary-protocol">Pulsar 协议</a>URL。</p>
<p>Pulsar协议 url 使用 <code>pulsar</code> scheme来指定被连接的集群，默认端口为6650。以下是 <code>localhost</code> 的示例:</p>
<pre><code class="hljs css language-http">pulsar://localhost:6650
</code></pre>
<p>如果你有多个broker，URL可能看起来如下：</p>
<pre><code class="hljs css language-http">pulsar://localhost:6550,localhost:6651,localhost:6652
</code></pre>
<p>生产环境的Pulsar 集群URL类似这样：</p>
<pre><code class="hljs css language-http">pulsar://pulsar.us-west.example.com:6650
</code></pre>
<p>If you're using <a href="/docs/zh-CN/next/security-tls-authentication">TLS</a> authentication, the URL will look like something like this:</p>
<pre><code class="hljs css language-http">pulsar+ssl://pulsar.us-west.example.com:6651
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="client"></a><a href="#client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Client</h2>
<p>你可以用一个URL来实例化一个连接到指定的Pulsar <a href="/docs/zh-CN/next/reference-terminology#cluster">集群</a>的 <a href="https://pulsar.incubator.apache.org/api/client/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
对象，像这样：</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650"</span>)
        .build();
</code></pre>
<p>如果你有多个broker，你可以如下初始化PulsarClient:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650,localhost:6651,localhost:6652"</span>)
        .build();
</code></pre>
<blockquote>
<h4><a class="anchor" aria-hidden="true" id="默认的broker-url是单机集群。"></a><a href="#默认的broker-url是单机集群。" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>默认的broker URL是单机集群。</h4>
<p>如果你使用<a href="/docs/zh-CN/next/standalone">单机模式</a>运行一个集群，broker将默认使用<code>pulsar://localhost:6650</code></p>
</blockquote>
<p>如果你创建客户端，可以使用<code>loadConf</code>配置。<code>loadConf</code>可用参数如下。</p>
<p>|类型|名称|</p>
<div style="width:260px">
  说明：
</div>
<p>| Default |---|---|---|--- String | <code>serviceUrl</code> |Service URL provider for Pulsar service | None String | <code>authPluginClassName</code> | Name of the authentication plugin | None String | <code>authParams</code> | String represents parameters for the authentication plugin</p>
<p><strong>Example</strong>  <br>
key1:val1,key2:val2|None long|<code>operationTimeoutMs</code>|Operation timeout |30000 long|<code>statsIntervalSeconds</code>|Interval between each stat info</p>
<p>Stats is activated with positive <code>statsInterval</code></p>
<p><code>statsIntervalSeconds</code> should be set to 1 second at least |60 int|<code>numIoThreads</code>| Number of threads used for handling connections to brokers | 1 int|<code>numListenerThreads</code>|Number of threads used for handling message listeners | 1 boolean|<code>useTcpNoDelay</code>|Whether to use TCP no-delay flag on the connection to disable Nagle algorithm |true boolean |<code>useTls</code> |Whether to use TLS encryption on the connection| false string | <code>tlsTrustCertsFilePath</code> |Path to the trusted TLS certificate file|None boolean|<code>tlsAllowInsecureConnection</code>|Whether the Pulsar client accepts untrusted TLS certificate from broker | false boolean | <code>tlsHostnameVerificationEnable</code> | Whether to enable TLS hostname verification|false int|<code>concurrentLookupRequest</code>|Number of concurrent lookup requests allowed to send on each broker connection to prevent overload on broker|5000 int|<code>maxLookupRequest</code>|Maximum number of lookup requests allowed on each broker connection to prevent overload on broker | 50000 int|<code>maxNumberOfRejectedRequestPerConnection</code>|Maximum number of rejected requests of a broker in a certain time frame (30 seconds) after the current connection is closed and the client creates a new connection to connect to a different broker|50 int|<code>keepAliveIntervalSeconds</code>|Seconds of keeping alive interval for each client broker connection|30 int|<code>connectionTimeoutMs</code>|Duration of waiting for a connection to a broker to be established</p>
<p>If the duration passes without a response from a broker, the connection attempt is dropped|10000 int|<code>requestTimeoutMs</code>|Maximum duration for completing a request |60000 int|<code>defaultBackoffIntervalNanos</code>| Default duration for a backoff interval | TimeUnit.MILLISECONDS.toNanos(100); long|<code>maxBackoffIntervalNanos</code>|Maximum duration for a backoff interval|TimeUnit.SECONDS.toNanos(30)</p>
<p>完整的配置参数列表参考 <a href="https://pulsar.incubator.apache.org/api/client/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 类的javadoc文档 。</p>
<blockquote>
<p>除了客户端级别的配置，你还可以使用 <a href="#configuring-producers">生产者</a>和<a href="#configuring-consumers">消费者</a>特定配置，你将在下面的章节中看到。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="producer"></a><a href="#producer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Producer</h2>
<p>在Pulsar中，生产者写消息到主题中。 一旦你实例化一个<a href="https://pulsar.incubator.apache.org/api/client/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
客户端对象(在<a href="#client-configuration">如上</a>z章节)，你可以创建一个<a href="https://pulsar.incubator.apache.org/api/client/org/apache/pulsar/client/api/Producer">Producer</a>
生产者用于特定的<a href="/docs/zh-CN/next/reference-terminology#topic">主题</a>。</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();

<span class="hljs-comment">// 然后你就可以发送消息到指定的broker 和topic上：</span>
producer.send(<span class="hljs-string">"My message"</span>.getBytes());
</code></pre>
<p>默认情况下，生产者生产的消息为字节数组。但是，你可以通过指定消息的<a href="#schemas">schema</a>来生成不同类型的消息。</p>
<pre><code class="hljs css language-java">Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();
stringProducer.send(<span class="hljs-string">"My message"</span>);
</code></pre>
<blockquote>
<p>在不再使用时，你需要确保关闭生产者、消费者和客户端：</p>
<pre><code class="hljs css language-java"></code></pre>
</blockquote>
<p>producer.close();
consumer.close();
client.close();</p>
<pre><code class="hljs">
关闭操作也可以是异步的：

```java
producer.closeAsync()
   .thenRun(<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> System.out.println(<span class="hljs-string">"Producer closed"</span>));
   .exceptionally(<span class="hljs-function"><span class="hljs-params">(ex)</span> -&gt;</span> {
       System.err.println(<span class="hljs-string">"Failed to close producer: "</span> + ex);
       <span class="hljs-keyword">return</span> ex;
   });
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="配置producer（生产者）"></a><a href="#配置producer（生产者）" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置Producer（生产者）</h3>
<p>如上例，在实例化<code>Producer</code>对象时指定唯一的topic名字，生产者使用的默认配置。</p>
<p>创建生产者时可以使用<code>loadConf</code>配置。下面列出<code>loadConf</code>可使用的参数。</p>
<p>类型|名称|</p>
<div style="width:300px">
  说明：
</div>| Default |\---|\---|\---|\--- String| 
<p><code>topicName</code>| Topic name| null| String|<code>producerName</code>|Producer name| null long|<code>sendTimeoutMs</code>|Message send timeout in ms.</p>
<p>If a message is not acknowledged by a server before the <code>sendTimeout</code> 过期，error被触发。|30000 boolean|<code>blockIfQueueFull</code>|If set to <code>true</code>, when the outgoing message queue is full, the <code>Send</code> and <code>SendAsync</code> methods of producer block rather than failing and throwing errors.</p>
<p>If set to <code>false</code>, when the outgoing message queue is full, the <code>Send</code> and <code>SendAsync</code> methods of producer fail and throw <code>ProducerQueueIsFullError</code> exceptions.</p>
<p>The size of the outgoing message queue is determined by the <code>MaxPendingMessages</code> parameter.|false int|<code>maxPendingMessages</code>|Maximum size of a queue holding pending messages.</p>
<p>For example, a message waiting to receive an acknowledgment from a <a href="reference-terminology.md#broker">broker</a>.</p>
<p>By default, when the queue is full, all calls to the <code>Send</code> and <code>SendAsync</code> methods fail <strong>unless</strong> <code>BlockIfQueueFull</code> is set to <code>true</code>.|1000 int|<code>maxPendingMessagesAcrossPartitions</code>|Maximum number of pending messages across partitions.</p>
<p>This setting is used to lower the max pending messages for each partition ({@link #setMaxPendingMessages(int)}) if the total exceeds the configured value.|50000 MessageRoutingMode|<code>messageRoutingMode</code>|Message routing logic for producers on <a href="concepts-architecture-overview.md#partitioned-topics">partitioned topics</a>.</p>
<p>This logic is applied only when no key is set on messages.</p>
<p>下面是可用的选项：</p>
<ul>
<li><p><code>pulsar.RoundRobinDistribution</code>: 轮训</p>
<ul>
<li><p><code>pulsar.UseSinglePartition</code>: 发布全部消息到单个分区</p>
<ul>
<li><p><code>pulsar.CustomPartition</code>: a custom partitioning scheme|<code>pulsar.RoundRobinDistribution</code> HashingScheme|<code>hashingScheme</code>|Hashing function that determines the partition on which a particular message is published (<strong>partitioned topics only</strong>).</p>
<p>Below are the available options:</p>
<ul>
<li><p><code>pulsar.JavaStringHash</code>: the equivalent of <code>String.hashCode()</code> in Java</p>
<ul>
<li><p><code>pulsar.Murmur3_32Hash</code>: applies the <a href="https://en.wikipedia.org/wiki/MurmurHash">Murmur3</a> hashing function</p>
<ul>
<li><p><code>pulsar.BoostHash</code>: applies the hashing function from C++'s <a href="https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html">Boost</a> library |<code>HashingScheme.JavaStringHash</code> ProducerCryptoFailureAction|<code>cryptoFailureAction</code>|Producer should take action when encryption fails.</p>
<ul>
<li><p><strong>FAIL</strong>: if encryption fails, unencrypted messages fail to send.</p></li>
<li><p><strong>SEND</strong>: if encryption fails, unencrypted messages are sent. |<code>ProducerCryptoFailureAction.FAIL</code> long|<code>batchingMaxPublishDelayMicros</code>|Time period within which messages sent will be batched.|TimeUnit.MILLISECONDS.toMicros(1) int|batchingMaxMessages|Maximum number of messages permitted in a batch.|1000 boolean|<code>batchingEnabled</code>|Enable batching of messages. |true CompressionType|<code>compressionType</code>|Message data compression type used by a producer.</p>
<p>Below are the available options:</p>
<ul>
<li><a href="https://github.com/lz4/lz4"><code>LZ4</code></a>
<ul>
<li><a href="https://zlib.net/"><code>ZLIB</code></a>
<ul>
<li><p><a href="https://facebook.github.io/zstd/"><code>ZSTD</code></a>  <br>
* <a href="https://google.github.io/snappy/"><code>SNAPPY</code></a>| No compression</p>
要使用非默认配置, 你可以设置多种可配置的参数。</p>
<pre><code class="hljs">  For a full listing, see the Javadoc for the {@inject: javadoc:ProducerBuilder:/client/org/apache/pulsar/client/api/ProducerBuilder} class. Here's an example:
  
  ```java
  Producer&lt;byte[]&gt; producer = client.newProducer()
      .topic(&quot;my-topic&quot;)
      .batchingMaxPublishDelay(10, TimeUnit.MILLISECONDS)
      .sendTimeout(10, TimeUnit.SECONDS)
      .blockIfQueueFull(true)
      .create();
  ```
  
  ### 消息路由
  
  当使用分区主题时，当你使用生产者发布消息时你可以指定路由模式。 有关使用 Java 客户端指定路由模式的更多内容, 请参见 [分区主题](cookbooks-partitioned.md) cookbook。
  
  ### 异步发送
  
  你可以使用Java客户端[异步](concepts-messaging.md#send-modes)发布消息。 使用异步发送，生产者将消息放入阻塞队列并立即返回。 然后，客户端将在后台将消息发送给broker。 如果队列已满（最大值可配置），则在调用API时，生产者可能会被阻塞或立即失败，具体取决于传递给生产者的参数。
  
  以下是异步发送操作的示例:
  
  ```java
  producer.sendAsync(&quot;my-async-message&quot;.getBytes()).thenAccept(msgId -&gt; {
      System.out.printf(&quot;Message with ID %s successfully sent&quot;, msgId);
  });
  ```
  
  As you can see from the example above, async send operations return a {@inject: javadoc:MessageId:/client/org/apache/pulsar/client/api/MessageId} wrapped in a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture).
  
  ### Configure messages
  
  除了value之外, 还可以在特定消息上设置其他选项：
  
  ```java
  producer.newMessage()
      .key(&quot;my-message-key&quot;)
      .value(&quot;my-async-message&quot;.getBytes())
      .property(&quot;my-key&quot;, &quot;my-value&quot;)
      .property(&quot;my-other-key&quot;, &quot;my-other-value&quot;)
      .send();
  ```
  
  对于前一种情况，也可以使用` sendAsync()`来终止构建器链，并获取future返回值。
  
  ## Consumer
  
  在Pulsar中，消费者订阅topic主题并处理生产者发布到这些主题的消息。 你可以首先实例化一个{@inject: javadoc:PulsarClient:/client/org/apache/pulsar/client/api/PulsarClient}对象并传递给他一个borker([如上所示](#client-configuration)) URL来实例化一个[消费者](reference-terminology.md#consumer)。
  
  一旦实例化一个{@inject: javadoc:PulsarClient:/client/org/apache/pulsar/client/api/PulsarClient} 对象，你可以指定一个[主题](reference-terminology.md#topic)和一个[订阅](concepts-messaging.md#subscription-modes)来创建一个 {@inject: javadoc:Consumer:/client/org/apache/pulsar/client/api/Consumer}消费者。
  
  ```java
  Consumer consumer = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscribe();
  ```
  
  `subscribe` 方法将自动将订阅消费者指定的主题和订阅。 一种让消费者监听主题的方法是使用`while`循环。 In this example loop, the consumer listens for messages, prints the contents of any message that's received, and then [acknowledges](reference-terminology.md#acknowledgment-ack) that the message has been processed. If the processing logic fails, we use [negative acknowledgement](reference-terminology.md#acknowledgment-ack) to have the message redelivered at a later point in time.
  
  ```java
  while (true) {
    // Wait for a message
    Message msg = consumer.receive();
  
    try {
        // Do something with the message
        System.out.printf(&quot;Message received: %s&quot;, new String(msg.getData()));
  
        // Acknowledge the message so that it can be deleted by the message broker
        consumer.acknowledge(msg);
    } catch (Exception e) {
        // Message failed to process, redeliver later
        consumer.negativeAcknowledge(msg);
    }
  }
  ```
  
  ### Configure consumer
  
  如果实例化 `消费者` 对象, 仅指定主题和订阅名称, 如上面的示例所示, 消费者将采用默认配置。
  
  If you create a consumer, you may use the `loadConf` configuration. Below are the available parameters used in `loadConf`.
  
  类型|名称|
  
  &lt;div style=&quot;width:300px&quot;&gt;
    说明：
  &lt;/div&gt;
  | Default |\---|\---|\---|\--- Set&lt;String&gt;| `topicNames`| Topic name| Sets.newTreeSet() Pattern| `topicsPattern`| Topic pattern |None String| `subscriptionName`| Subscription name| None SubscriptionType| `subscriptionType`| Subscription type   
    
  There are three subscription types:
  
  * Exclusive
  * Failover（灾备）
  * Shared（共享）|SubscriptionType.Exclusive int | 
  `receiverQueueSize` | Size of a consumer's receiver queue.   
    
  For example, the number of messages that can be accumulated by a consumer before an application calls `Receive`.   
    
  A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.| 1000 long|`acknowledgementsGroupTimeMicros`|Group a consumer acknowledgment for a specified time.  
    
  By default, a consumer uses 100ms grouping time to send out acknowledgments to a broker.  
    
  Setting a group time of 0 sends out acknowledgments immediately.   
    
  A longer ack group time is more efficient at the expense of a slight increase in message re-deliveries after a failure.|TimeUnit.MILLISECONDS.toMicros(100) long|`negativeAckRedeliveryDelayMicros`|Delay to wait before redelivering messages that have failed to be process.  
    
  When an application uses {@link Consumer#negativeAcknowledge(Message)}, failed messages are redelivered after a fixed timeout. |TimeUnit.MINUTES.toMicros(1) int |`maxTotalReceiverQueueSizeAcrossPartitions`|Max total receiver queue size across partitions.  
    
  This setting reduces the receiver queue size for individual partitions if the total receiver queue size exceeds this value.|50000 String|`consumerName`|Consumer name|null long|`ackTimeoutMillis`|Timeout of unacked messages|0 long|`tickDurationMillis`|Granularity of the ack-timeout redelivery.  
    
  Using an higher `tickDurationMillis` reduces the memory overhead to track messages when the ack-timeout is set to a bigger value (for example, 1 hour).|1000 int|`priorityLevel`|Priority level for a consumer to which a broker gives more priority while dispatching messages in the shared subscription mode.   
    
  Here, the broker follows descending priorities. For example, 0=max-priority, 1, 2,...  
    
  In the shared subscription mode, the broker **first dispatches messages to the max priority level consumers if they have permits**. Otherwise, the broker considers next priority level consumers.  
    
  **Example 1**  
    
  If a subscription has consumerA with `priorityLevel` 0 and consumerB with `priorityLevel` 1, then the broker **only dispatches messages to consumerA until it runs out permits** and then starts dispatching messages to consumerB.  
    
  **Example 2**  
    
  Consumer Priority, Level, Permits  
  C1, 0, 2  
  C2, 0, 1  
  C3, 0, 1  
  C4, 1, 2  
  C5, 1, 1  
    
  Order in which a broker dispatches messages to consumers is: C1, C2, C3, C1, C4, C5, C4.|0 ConsumerCryptoFailureAction|`cryptoFailureAction`|Consumer should take action when it receives a message that can not decrypt.  
    
  
  
  * **FAIL**: this is the default option to fail messages until crypto succeeds.
    
  
  
  * **DISCARD**: message is silently acknowledged and not delivered to an application.
    
  
  
  * **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.  
        
      If message are compressed, the decompression fails.   
        
      If messages contain batch messages, a client is not be able to retrieve individual messages in batch.  
        
      Delivered encrypted message contains {@link EncryptionContext} which contains encryption and compression information in it using which application can decrypt consumed message payload.|ConsumerCryptoFailureAction.FAIL SortedMap&lt;String, String&gt;|
  `properties`|A name or value property of this consumer.  
    
  `properties` is application defined metadata that can be attached to a consumer.   
    
  When getting a topic stats, this metadata is associated to the consumer stats for easier identification.|new TreeMap&lt;&gt;() boolean|`readCompacted`|If `readCompacted` is enabled, a consumer reads messages from a compacted topic rather than reading a full message backlog of a topic.  
    
  This means if a topic has been compacted, a consumer only see the latest value for each key in the topic, up until the point in the topic message when backlog that has been compacted. Beyond that point, the messages are sent as normal.  
    
  `readCompacted` can only be enabled on subscriptions to persistent topics, which have a single active consumer (for example, failure or exclusive subscriptions).   
    
  Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.|false SubscriptionInitialPosition|`subscriptionInitialPosition`|Initial position at which to set cursor when subscribing to a topic at first time.|SubscriptionInitialPosition.Latest int|`patternAutoDiscoveryPeriod`|Topic auto discovery period when using a pattern for topic's consumer.  
    
  The default and minimum value is 1 minute.|1 RegexSubscriptionMode|`regexSubscriptionMode`|When subscribing to a topic using a regular expression, you can pick a certain type of topics.  
    
  
  
  * **PersistentOnly**: only subscribe to persistent topics.
    
  
  
  * **NonPersistentOnly**: only subscribe to non-persistent topics.
    
  
  
  * **AllTopics**: subscribe to both persistent and non-persistent topics.|RegexSubscriptionMode.PersistentOnly DeadLetterPolicy|
  `deadLetterPolicy`|Dead letter policy for consumers.  
    
  By default, some messages are redelivered many times possible, even to the extent that it can be never stop.  
    
  By using the dead letter mechanism, messages have the max redelivery count. **When message exceeding the maximum number of redeliveries, messages are sent to the Dead Letter Topic and acknowledged automatically**.  
    
  You can enable the dead letter mechanism by setting `deadLetterPolicy`.  
    
  **Example**  
    
  `client.newConsumer()&lt;br/&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10).build())&lt;br/&gt;.subscribe();`  
    
  Default dead letter topic name is `{TopicName}-{Subscription}-DLQ`.  
    
  To set a custom dead letter topic name:  
  `client.newConsumer()&lt;br/&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10)&lt;br/&gt;.deadLetterTopic(&quot;your-topic-name&quot;).build())&lt;br/&gt;.subscribe();`  
    
  When the dead letter policy is specified and no `ackTimeoutMillis` is specified, then the ack timeout is set to 30000 millisecond.|None boolean|`autoUpdatePartitions`|If `autoUpdatePartitions` is enabled, a consumer subscribes to partition increasement automatically.  
    
  **Note**: this is only for partitioned consumers.|true boolean|`replicateSubscriptionState`|If `replicateSubscriptionState` is enabled, a subscription state is replicated to geo-replicated clusters.|false
  
  要使用非默认配置, 你可以设置多种可配置的参数。 有关完整列表, 请参阅 {@inject: javadoc:ConsumerBuilder:/client/org/apache/pulsar/client/api/ConsumerBuilder}类javadoc文档。 下面是一个示例：
  
  这是一个示例配置：
  
  ```java
  Consumer consumer = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .ackTimeout(10, TimeUnit.SECONDS)
          .subscriptionType(SubscriptionType.Exclusive)
          .subscribe();
  ```
  
  ### 异步接收
  
  `receive`方法将异步接受消息（消费者处理器将被阻塞，直到有消息到达）。 你也可以使用[异步接收方法](concepts-messaging.md#receive-modes)，这将在一个新消息到达时立即返回一个[`CompletableFuture`](http://www.baeldung.com/java-completablefuture)对象。
  
  下面是一个示例：
  
  ```java
  CompletableFuture&lt;Message&gt; asyncMessage = consumer.receiveAsync();
  ```
  
  Async receive operations return a {@inject: javadoc:Message:/client/org/apache/pulsar/client/api/Message} wrapped inside of a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture).
  
  ### Batch receive
  
  Use `batchReceive` can receive multiple messages for each calls.
  
  下面是一个示例：
  
  ```java
  Messages messages = consumer.batchReceive();
  for (message in messages) {
    // do something
  }
  consumer.acknowledge(messages)
  ```
  
  &gt; Note:
  &gt; 
  &gt; Batch receive policy can limit the number and bytes of messages in a single batch, and can specify a timeout for waiting for enough messages.
  &gt; 
  &gt; The batch receive will be completed as long as any one of the conditions(has enough number of messages, has enough of bytes of messages, wait timeout) is met.
  &gt; 
  &gt; ```java
  &gt; Consumer consumer = client.newConsumer()
  &gt;         .topic(&quot;my-topic&quot;)
  &gt;         .subscriptionName(&quot;my-subscription&quot;)
  &gt;         .batchReceivePolicy(BatchReceivePolicy.builder()
  &gt;              .maxNumMessages(100)
  &gt;              .maxNumBytes(1024 * 1024)
  &gt;              .timeout(200, TimeUnit.MILLISECONDS)
  &gt;              .build())
  &gt;         .subscribe();
  &gt; ```
  &gt; 
  &gt; And the default batch receive policy is:
  &gt; 
  &gt; ```java
  &gt; BatchReceivePolicy.builder()
  &gt;     .maxNumMessage(-1)
  &gt;     .maxNumBytes(10 * 1024 * 1024)
  &gt;     .timeout(100, TimeUnit.MILLISECONDS)
  &gt;     .build();
  &gt; ```
  
  ### 多主题订阅
  
  消费者除了订阅单个Pulsar主题外，你还可以使用[多主题订阅](concepts-messaging.md#multi-topic-subscriptions)订阅多个主题。 若要使用多主题订阅, 可以提供一个topic正则表达式 (regex) 或 主题`List` 。 如果通过 regex 选择主题, 则所有主题都必须位于同一Pulsar命名空间中。
  
  下面是一些示例:
  
  ```java
  import org.apache.pulsar.client.api.Consumer;
  import org.apache.pulsar.client.api.PulsarClient;
  
  import java.util.Arrays;
  import java.util.List;
  import java.util.regex.Pattern;
  
  ConsumerBuilder consumerBuilder = pulsarClient.newConsumer()
          .subscriptionName(subscription);
  
  // 订阅命名空间中的所有主题
  Pattern allTopicsInNamespace = Pattern.compile(&quot;persistent://public/default/.*&quot;);
  Consumer allTopicsConsumer = consumerBuilder
          .topicsPattern(allTopicsInNamespace)
          .subscribe();
  
  // 使用regex订阅命名空间中的主题子集
  Pattern someTopicsInNamespace = Pattern.compile(&quot;persistent://public/default/foo.*&quot;);
  Consumer allTopicsConsumer = consumerBuilder
          .topicsPattern(someTopicsInNamespace)
          .subscribe();
  ```
  
  你还可以订阅明确的主题列表 (如果愿意, 可跨命名空间):
  
  ```java
  List&lt;String&gt; topics = Arrays.asList(
          &quot;topic-1&quot;,
          &quot;topic-2&quot;,
          &quot;topic-3&quot;
  );
  
  Consumer multiTopicConsumer = consumerBuilder
          .topics(topics)
          .subscribe();
  
  // 或者：
  Consumer multiTopicConsumer = consumerBuilder
          .topics(
              &quot;topic-1&quot;,
              &quot;topic-2&quot;,
              &quot;topic-3&quot;
          )
          .subscribe();
  ```
  
  您还可以使用 `subscribeAsync` 方法异步订阅多个主题, 而不是同步 `subscribe` 方法。下面是一个示例:
  
  ```java
  Pattern allTopicsInNamespace = Pattern.compile(&quot;persistent://public/default.*&quot;);
  consumerBuilder
          .topics(topics)
          .subscribeAsync()
          .thenAccept(this::receiveMessageFromConsumer);
  
  private void receiveMessageFromConsumer(Consumer consumer) {
      consumer.receiveAsync().thenAccept(message -&gt; {
                  // Do something with the received message
                  receiveMessageFromConsumer(consumer);
              });
  }
  ```
  
  ### 订阅模型
  
  Pulsar has various [subscription modes](concepts-messaging#subscription-modes) to match different scenarios. A topic can have multiple subscriptions with different subscription modes. However, a subscription can only have one subscription mode at a time.
  
  A subscription is identified with the subscription name, and a subscription name can specify only one subscription mode at a time. You can change the subscription mode, yet you have to let all existing consumers of this subscription offline first.
  
  Different subscription modes have different message distribution modes. This section describes the differences of subscription modes and how to use them.
  
  In order to better describe their differences, assuming you have a topic named &quot;my-topic&quot;, and the producer has published 10 messages.
  
  ```java
  Producer&lt;String&gt; producer = client.newProducer(Schema.STRING)
          .topic(&quot;my-topic&quot;)
          .enableBatching(false)
          .create();
  // 3 messages with &quot;key-1&quot;, 3 messages with &quot;key-2&quot;, 2 messages with &quot;key-3&quot; and 2 messages with &quot;key-4&quot;
  producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-1&quot;).send();
  producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-2&quot;).send();
  producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-3&quot;).send();
  producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-1&quot;).send();
  producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-2&quot;).send();
  producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-3&quot;).send();
  producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-1&quot;).send();
  producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-2&quot;).send();
  producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-1&quot;).send();
  producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-2&quot;).send();
  ```
  
  #### Exclusive
  
  Create a new consumer and subscribe with the `Exclusive` subscription mode.
  
  ```java
  Consumer consumer = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Exclusive)
          .subscribe()
  ```
  
  Only the first consumer is allowed to the subscription, other consumers receive an error. The first consumer receives all 10 messages, and the consuming order is the same as the producing order.
  
  &gt; Note:
  &gt; 
  &gt; If topic is a partitioned topic, the first consumer subscribes to all partitioned topics, other consumers are not assigned with partitions and receive an error.
  
  #### Failover（灾备）
  
  Create new consumers and subscribe with the`Failover` subscription mode.
  
  ```java
  Consumer consumer1 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Failover)
          .subscribe()
  Consumer consumer2 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Failover)
          .subscribe()
  //conumser1 is the active consumer, consumer2 is the standby consumer.
  //consumer1 receives 5 messages and then crashes, consumer2 takes over as an  active consumer.
  
  
  ```
  
  Multiple consumers can attach to the same subscription, yet only the first consumer is active, and others are standby. When the active consumer is disconnected, messages will be dispatched to one of standby consumers, and the standby consumer becomes active consumer.
  
  If the first active consumer receives 5 messages and is disconnected, the standby consumer becomes active consumer. Consumer1 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-1&quot;)
      (&quot;key-1&quot;, &quot;message-1-2&quot;)
      (&quot;key-1&quot;, &quot;message-1-3&quot;)
      (&quot;key-2&quot;, &quot;message-2-1&quot;)
      (&quot;key-2&quot;, &quot;message-2-2&quot;)
      
  
  consumer2 will receive:
  
      (&quot;key-2&quot;, &quot;message-2-3&quot;)
      (&quot;key-3&quot;, &quot;message-3-1&quot;)
      (&quot;key-3&quot;, &quot;message-3-2&quot;)
      (&quot;key-4&quot;, &quot;message-4-1&quot;)
      (&quot;key-4&quot;, &quot;message-4-2&quot;)
      
  
  &gt; Note:
  &gt; 
  &gt; If a topic is a partitioned topic, each partition only has one active consumer, messages of one partition only distributed to one consumer, messages of multiple partitions are distributed to multiple consumers.
  
  #### Shared（共享）
  
  Create new consumers and subscribe with `Shared` subscription mode:
  
  ```java
  Consumer consumer1 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Shared)
          .subscribe()
  
  Consumer consumer2 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Shared)
          .subscribe()
  //Both consumer1 and consumer 2 is active consumers.
  ```
  
  In shared subscription mode, multiple consumers can attach to the same subscription and message are delivered in a round robin distribution across consumers.
  
  If a broker dispatches only one message at a time, consumer1 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-1&quot;)
      (&quot;key-1&quot;, &quot;message-1-3&quot;)
      (&quot;key-2&quot;, &quot;message-2-2&quot;)
      (&quot;key-3&quot;, &quot;message-3-1&quot;)
      (&quot;key-4&quot;, &quot;message-4-1&quot;)
      
  
  consumer 2 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-2&quot;)
      (&quot;key-2&quot;, &quot;message-2-1&quot;)
      (&quot;key-2&quot;, &quot;message-2-3&quot;)
      (&quot;key-3&quot;, &quot;message-3-2&quot;)
      (&quot;key-4&quot;, &quot;message-4-2&quot;)
      
  
  `Shared` subscription is different from `Exclusive` and `Failover` subscription modes. `Shared` subscription has better flexibility, but cannot provide order guarantee.
  
  #### Key_shared
  
  This is a new subscription mode since 2.4.0 release, create new consumers and subscribe with `Key_Shared` subscription mode:
  
  ```java
  Consumer consumer1 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Key_Shared)
          .subscribe()
  
  Consumer consumer2 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Key_Shared)
          .subscribe()
  //Both consumer1 and consumer2 are active consumers.
  ```
  
  `Key_Shared` subscription is like `Shared` subscription, all consumers can attach to the same subscription. But it is different from `Key_Shared` subscription, messages with the same key are delivered to only one consumer in order. The possible distribution of messages between different consumers(by default we do not know in advance which keys will be assigned to a consumer, but a key will only be assigned to a consumer at the same time. ) .
  
  consumer1 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-1&quot;)
      (&quot;key-1&quot;, &quot;message-1-2&quot;)
      (&quot;key-1&quot;, &quot;message-1-3&quot;)
      (&quot;key-3&quot;, &quot;message-3-1&quot;)
      (&quot;key-3&quot;, &quot;message-3-2&quot;)
      
  
  consumer 2 will receive:
  
      (&quot;key-2&quot;, &quot;message-2-1&quot;)
      (&quot;key-2&quot;, &quot;message-2-2&quot;)
      (&quot;key-2&quot;, &quot;message-2-3&quot;)
      (&quot;key-4&quot;, &quot;message-4-1&quot;)
      (&quot;key-4&quot;, &quot;message-4-2&quot;)
      
  
  &gt; Note:
  &gt; 
  &gt; If the message key is not specified, messages without key will be dispatched to one consumer in order by default.
  
  ## Reader
  
  使用 [reader 接口](concepts-clients.md#reader-interface), Pulsar客户可以在主题中“手动定位”自己，从指定的消息开始向前读取所有消息。 The Pulsar API for Java enables you to create {@inject: javadoc:Reader:/client/org/apache/pulsar/client/api/Reader} objects by specifying a topic, a {@inject: javadoc:MessageId:/client/org/apache/pulsar/client/api/MessageId}, and {@inject: javadoc:ReaderConfiguration:/client/org/apache/pulsar/client/api/ReaderConfiguration}.
  
  下面是一个示例：
  
  ```java
  ReaderConfiguration conf = new ReaderConfiguration();
  byte[] msgIdBytes = // 一些消息ID 的字节数组
  MessageId id = MessageId.fromByteArray(msgIdBytes);
  Reader reader = pulsarClient.newReader()
          .topic(topic)
          .startMessageId(id)
          .create();
  
  while (true) {
      Message message = reader.readNext();
      // 处理消息
  }
  ```
  
  在上面的示例中，实例化一个`Reader`对象对指定的主题和消息（ID）; reader将遍历主题中`msgIdBytes`(取值方式取决于应用程序) 之后的消息。
  
  上面的示例代码展示了`Reader`对象指向特定的消息(ID)，但你也可以使用`MessageId.earliest`来指向topic上最早可用的消息，使用`MessageId.latest`指向最新的消息。
  
  If you create a reader, you may use the `loadConf` configuration. Below are the available parameters used in `loadConf`.
  
  |类型|名称|
  
  &lt;div style=&quot;width:300px&quot;&gt;
    说明：
  &lt;/div&gt;
  | Default |\---|\---|\---|\--- String|`topicName`|Topic name. |None int|`receiverQueueSize`|Size of a consumer's receiver queue.  
    
  For example, the number of messages that can be accumulated by a consumer before an application calls `Receive`.  
    
  A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.|1000 ReaderListener&lt;T&gt;|`readerListener`|A listener that is called for message received.|None String|`readerName`|Read name.|null String|`subscriptionRolePrefix`|Prefix of subscription role. |null CryptoKeyReader|`cryptoKeyReader`|Interface that abstracts the access to a key store.|null ConsumerCryptoFailureAction|`cryptoFailureAction`|Consumer should take action when it receives a message that can not decrypt.  
    
  
  
  * **FAIL**: this is the default option to fail messages until crypto succeeds.
    
  
  
  * **DISCARD**: message is silently acknowledged and not delivered to an application.
    
  
  
  * **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.  
        
      If message are compressed, the decompression fails.   
        
      If messages contain batch messages, a client is not be able to retrieve individual messages in batch.  
        
      Delivered encrypted message contains {@link EncryptionContext} which contains encryption and compression information in it using which application can decrypt consumed message payload.|ConsumerCryptoFailureAction.FAIL boolean|
  `readCompacted`|If `readCompacted` is enabled, a consumer reads messages from a compacted topic rather than reading a full message backlog of a topic.  
    
  This means if a topic has been compacted, a consumer only see the latest value for each key in the topic, up until the point in the topic message when backlog that has been compacted. Beyond that point, the messages are sent as normal.  
    
  `readCompacted` can only be enabled on subscriptions to persistent topics, which have a single active consumer (for example, failure or exclusive subscriptions).   
    
  Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.|false boolean|`resetIncludeHead`|If set to true, the first message to be returned is the one specified by `messageId`.  
    
  If set to false, the first message to be returned is the one next to the message specified by `messageId`.|false
  
  ## Schema
  
  In Pulsar, all message data consists of byte arrays &quot;under the hood.&quot; [Message schemas](schema-get-started.md) enable you to use other types of data when constructing and handling messages (from simple types like strings to more complex, application-specific types). 如果在不指定schema的情况下构造 [生产者](#producers)，则生产者只能生成类型为 `byte[] `的消息。 下面是一个示例：
  
  ```java
  Producer&lt;byte[]&gt; producer = client.newProducer()
          .topic(topic)
          .create();
  ```
  
  上面的生产者相当于 `Producer&lt;byte[]&gt;` (实际上, 你应该 *总是* 显式指定类型)。 如果你想让产生者使用不同类型的数据，你需要指定一个**schema**来通知Pulsar 在[topic](reference-terminology.md#topic)上传输哪种类型的数据。
  
  ### Schema实例
  
  假设您有一个 `SensorReading` 类, 你想通过Pulsar主题进行传输:
  
  ```java
  public class SensorReading {
      public float temperature;
  
      public SensorReading(float temperature) {
          this.temperature = temperature;
      }
  
      // A no-arg constructor is required
      public SensorReading() {
      }
  
      public float getTemperature() {
          return temperature;
      }
  
      public void setTemperature(float temperature) {
          this.temperature = temperature;
      }
  }
  ```
  
  你可以创建一个`Producer&lt;SensorReading&gt;` (或`Consumer&lt;SensorReading&gt;`)像这样：
  
  ```java
  Producer&lt;SensorReading&gt; producer = client.newProducer(JSONSchema.of(SensorReading.class))
          .topic(&quot;sensor-readings&quot;)
          .create();
  ```
  
  以下schema格式目前可用于 Java:
  
  * 无schema 或者字节数组schema(可以使用`Schema.BYTES`)：
      
      ```java
      Producer&lt;byte[]&gt; bytesProducer = client.newProducer(Schema.BYTES)
          .topic(&quot;some-raw-bytes-topic&quot;)
          .create();
      ```
      
      或者:
      
      ```java
      Producer&lt;byte[]&gt; bytesProducer = client.newProducer()
          .topic(&quot;some-raw-bytes-topic&quot;)
          .create();
      ```
  
  * `String`UTF-8编码的字符串数据。可以使用`Schema.STRING`：
      
      ```java
      Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
          .topic(&quot;some-string-topic&quot;)
          .create();
      ```
  
  * JSON schemas can be created for POJOs using `Schema.JSON`. Here's an example:
      
      ```java
      Producer&lt;MyPojo&gt; pojoProducer = client.newProducer(Schema.JSON(MyPojo.class))
          .topic(&quot;some-pojo-topic&quot;)
          .create();
      ```
  
  * Protobuf schemas can be generate using `Schema.PROTOBUF`. The following example shows how to create the Protobuf schema and use it to instantiate a new producer:
      
      ```java
      Producer&lt;MyProtobuf&gt; protobufProducer = client.newProducer(Schema.PROTOBUF(MyProtobuf.class))
          .topic(&quot;some-protobuf-topic&quot;)
          .create();
      ```
  
  * Avro schemas can be defined with the help of `Schema.AVRO`. The next code snippet demonstrates the creation and usage of the Avro schema:
      
      ```java
      Producer&lt;MyAvro&gt; avroProducer = client.newProducer(Schema.AVRO(MyAvro.class))
          .topic(&quot;some-avro-topic&quot;)
          .create();
      ```
  
  ## 身份验证
  
  Pulsar目前支持两种身份验证方案：[ TLS ](security-tls-authentication.md)和[ Athenz ](security-athenz.md)。 Pulsar Java客户端中两者可以一起使用。
  
  ### TLS Authentication
  
  要使用[TLS](security-tls-authentication.md)，你需要使用`setUseTls`方法设置TLS为`true`，将您的Pulsar客户端指向TLS证书路径，并提供证书和密钥文件的路径。
  
  这是一个示例配置：
  
  ```java
  Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
  authParams.put(&quot;tlsCertFile&quot;, &quot;/path/to/client-cert.pem&quot;);
  authParams.put(&quot;tlsKeyFile&quot;, &quot;/path/to/client-key.pem&quot;);
  
  Authentication tlsAuth = AuthenticationFactory
          .create(AuthenticationTls.class.getName(), authParams);
  
  PulsarClient client = PulsarClient.builder()
          .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
          .enableTls(true)
          .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
          .authentication(tlsAuth)
          .build();
  ```
  
  ### Athenz
  
  要使用[Athenz](security-athenz.md)做为身份认证提供者，你需要[use TLS](#tls-authentication)并且在hash提供如下四个参数的值：
  
  * `tenantDomain`
  * `tenantService`
  * `providerDomain`
  * `privateKey`
  
  还可以设置可选的 `keyId`。下面是一个配置示例:
  
  ```java
  Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
  authParams.put(&quot;tenantDomain&quot;, &quot;shopping&quot;); // Tenant domain name
  authParams.put(&quot;tenantService&quot;, &quot;some_app&quot;); // Tenant service name
  authParams.put(&quot;providerDomain&quot;, &quot;pulsar&quot;); // Provider domain name
  authParams.put(&quot;privateKey&quot;, &quot;file:///path/to/private.pem&quot;); // Tenant private key path
  authParams.put(&quot;keyId&quot;, &quot;v1&quot;); // Key id for the tenant private key (optional, default: &quot;0&quot;)
  
  Authentication athenzAuth = AuthenticationFactory
          .create(AuthenticationAthenz.class.getName(), authParams);
  
  PulsarClient client = PulsarClient.builder()
          .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
          .enableTls(true)
          .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
          .authentication(athenzAuth)
          .build();
  ```
  
  &gt; #### 支持的格式：
  &gt; 
  &gt; `privateKey`参数支持如下三种格式： * `file:///path/to/file` * `file:/path/to/file` * `data:application/x-pem-file;base64,&lt;base64-encoded value&gt;`</code></pre></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-CN/next/security-extending"><span class="arrow-prev">← </span><span>Extending</span></a><a class="docs-next button" href="/docs/zh-CN/next/client-libraries-go"><span>Go</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#安装">安装</a><ul class="toc-headings"><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ul></li><li><a href="#连接url">连接URL</a></li><li><a href="#client">Client</a></li><li><a href="#producer">Producer</a><ul class="toc-headings"><li><a href="#配置producer（生产者）">配置Producer（生产者）</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 The Apache Software Foundation. All Rights Reserved. Apache, Apache Pulsar and the Apache feather logo are trademarks of The Apache Software Foundation.</section><span><script>
      const community = document.querySelector("a[href='#community']").parentNode;
      const communityMenu =
        '<li>' +
        '<a id="community-menu" href="#">Community <span style="font-size: 0.75em">&nbsp;▼</span></a>' +
        '<div id="community-dropdown" class="hide">' +
          '<ul id="community-dropdown-items">' +
            '<li><a href="/zh-CN/contact">Contact</a></li>' +
            '<li><a href="/zh-CN/contributing">Contributing</a></li>' +
            '<li><a href="/zh-CN/coding-guide">Coding guide</a></li>' +
            '<li><a href="/zh-CN/events">Events</a></li>' +
            '<li><a href="https://twitter.com/Apache_Pulsar" target="_blank">Twitter &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/wiki" target="_blank">Wiki &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/issues" target="_blank">Issue tracking &#x2750</a></li>' +
            '<li>&nbsp;</li>' +
            '<li><a href="/zh-CN/resources">Resources</a></li>' +
            '<li><a href="/zh-CN/team">Team</a></li>' +
            '<li><a href="/zh-CN/powered-by">Powered By</a></li>' +
          '</ul>' +
        '</div>' +
        '</li>';

      community.innerHTML = communityMenu;

      const communityMenuItem = document.getElementById("community-menu");
      const communityDropDown = document.getElementById("community-dropdown");
      communityMenuItem.addEventListener("click", function(event) {
        event.preventDefault();

        if (communityDropDown.className == 'hide') {
          communityDropDown.className = 'visible';
        } else {
          communityDropDown.className = 'hide';
        }
      });
    </script></span></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'd226a455cecdd4bc18a554c1b47e5b52',
                indexName: 'apache_pulsar',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN","version:next"]}
              });
            </script></body></html>